<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HappySad</title>
  
  <subtitle>-RunDatGame</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-10-15T13:27:44.651Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>SOMEBODYZ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OJ [每日一题] 10-15</title>
    <link href="http://example.com/2022/10/15/OJ-10-15/"/>
    <id>http://example.com/2022/10/15/OJ-10-15/</id>
    <published>2022-10-15T08:39:15.000Z</published>
    <updated>2022-10-15T13:27:44.651Z</updated>
    
    <content type="html"><![CDATA[<h1 id="P1709-渣渣辉的井字棋"><a href="#P1709-渣渣辉的井字棋" class="headerlink" title="P1709 渣渣辉的井字棋"></a><a href="https://sustoj.com/p/P1709">P1709 渣渣辉的井字棋</a></h1><p><em>HOLYSHIT</em><br><em>oj 上这些题好麻烦啊 还是我太菜了。。。</em></p><ul><li><p>又要自己输入 还要考虑各种奇葩的测试数据 *</p></li><li><p>不是 WRONG ANSWER 就是 RUNTIME ERROR…..*</p></li><li><p>今天一道渣渣辉的井字棋给我整不会了，主要是一直有一个数据是 WA<br>还好现在发现错在哪了 *</p></li><li><p>设置自己下的棋在二维数组中相应位置的值为 1</p></li><li><p>不是自己的或者空的就设为 - 1 方便后面判断是否胜利了</p></li><li><p>胜利方式 1：两个对角线之一和为 3</p></li><li><p>胜利方式 2: 三行三列之一的单行和或者单列和为 3</p></li></ul><p>输入样例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">**0</span><br><span class="line">*0*</span><br><span class="line">0**</span><br><span class="line"></span><br><span class="line">*0*</span><br><span class="line">0**</span><br><span class="line">0**</span><br><span class="line"></span><br><span class="line">***</span><br><span class="line">***</span><br><span class="line">000</span><br></pre></td></tr></table></figure><p>输出样例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="type">char</span> a [<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> d [<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line">    <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> h=<span class="number">0</span>,l=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">                cin&gt;&gt;a [i][<span class="number">0</span>]&gt;&gt;a [i][<span class="number">1</span>]&gt;&gt;a [i][<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(a [i][j]==<span class="string">&#x27;*&#x27;</span>) d [i][j]=<span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">else</span> d [i][j]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="type">int</span> dz=<span class="number">0</span>,dy=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 以上都是赋值过程 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            dz+=d [i][i];   <span class="comment">//dz 是正对角线上的和 </span></span><br><span class="line">            dy+=d [i][<span class="number">2</span>-i]; <span class="comment">//dy 是逆对角线上的和 </span></span><br><span class="line">            <span class="keyword">if</span>(dy==<span class="number">3</span>||dz==<span class="number">3</span>)<span class="comment">// 胜利方式 1：两个对角线之一和为 3</span></span><br><span class="line">                flag=<span class="number">1</span>; </span><br><span class="line">            <span class="comment">// 胜利方式 2：三行三列之一的单行和或者单列和为 3</span></span><br><span class="line">            <span class="keyword">if</span>((d [i][<span class="number">0</span>]+d [i][<span class="number">1</span>]+d [i][<span class="number">2</span>]==<span class="number">3</span>)||(d [<span class="number">0</span>][i]+d [<span class="number">1</span>][i]+d [<span class="number">2</span>][i]==<span class="number">3</span>))</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//flag 为 1 说明胜利了 要输出 yes 反同 </span></span><br><span class="line">        <span class="keyword">if</span>(flag!=<span class="number">1</span>) cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="P1783-Subsequence"><a href="#P1783-Subsequence" class="headerlink" title="P1783  Subsequence"></a><a href="https://sustoj.com/p/P1783?tid=63496c9cfa854f10b1a38186">P1783  Subsequence</a></h1><p>记录一个坑，长个记性 因为这个浪费了很多时间<br><code>vector&lt;long long int&gt; ans (100010);</code><br><code>滑动窗口</code> <code>双指针</code></p><ul><li>简而言之就是两个指针让右指针先走边走边判断和是否大于给定 s 了 </li><li>如果大于：右指针停下来，先记录此时的窗口大小：right-left 然后让左指针向右即缩小窗口</li><li>最后当右指针到头了  返回之前所记录的最小窗口大小即可</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> N,S;</span><br><span class="line">    <span class="type">int</span> M; </span><br><span class="line">    <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(<span class="number">100010</span>)</span></span>;   <span class="comment">// 之前的数组大小是 100001 死活 AC 不了 ，没想到改了这个就好了 。。</span></span><br><span class="line">    cin&gt;&gt;M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">        cin&gt;&gt;N&gt;&gt;S;</span><br><span class="line">        <span class="type">int</span> min_size=<span class="number">100000</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">            cin&gt;&gt;ans [j];</span><br><span class="line">               <span class="comment">//for (int j=0;j&lt;N;j++) cout&lt;&lt; ans [j];</span></span><br><span class="line">               <span class="keyword">while</span>(r&lt;N)&#123;</span><br><span class="line">             sum +=ans [r++]; </span><br><span class="line">             <span class="keyword">while</span>(sum &gt;= S)&#123;</span><br><span class="line">                min_size = <span class="built_in">min</span>(min_size,r-l);</span><br><span class="line">                sum-=ans [l++]; </span><br><span class="line">             &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min_size&gt;N) min_size=<span class="number">0</span>;</span><br><span class="line">        cout&lt;&lt;min_size&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="P1641-电子狗的心事"><a href="#P1641-电子狗的心事" class="headerlink" title="P1641  电子狗的心事"></a><a href="https://sustoj.com/p/P1641">P1641  电子狗的心事</a></h1><ul><li>电子狗也挺变态的，它的心事都成了别人的心事了 * </li><li>主要是我一开始想错了 想着必须得回到原点 *<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(i==<span class="number">0</span>||i%<span class="number">4</span>==<span class="number">0</span>) y+=a [i];</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>) y-=a [i];</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">0</span>) x+=a [i];</span><br><span class="line">           <span class="keyword">else</span> x-=a [i];</span><br><span class="line">           <span class="keyword">if</span>(i&gt;=<span class="number">3</span>&amp;&amp;(x==<span class="number">0</span>&amp;&amp;y==<span class="number">0</span>||map [x]==y)) &#123;</span><br><span class="line">               cout&lt;&lt;i+<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">               <span class="keyword">goto</span> outloop ;</span><br><span class="line">           &#125; </span><br><span class="line">           map.<span class="built_in">emplace</span>(x,y);</span><br><span class="line">       &#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;regret&quot;</span>&lt;&lt;endl;</span><br></pre></td></tr></table></figure></li><li>其实路过也行，所以用走的边长来判断</li><li>这东西想起来很麻烦 要模拟 用笔画一下就方便了</li><li>这里分为四种情况 <ul><li>只走了三步不可能回到原点</li><li>走了四步并且满足条件<br><code>a [i]&gt;=a [i-2]&amp;&amp;a [i-1]&lt;=a [i-3]</code> </li><li>走了五步并且满足条件<br><code>a [i-1]==a [i-3]&amp;&amp;a [i-4]+a [i]&gt;=a [i-2]</code></li><li>走了六步并且满足条件<br><code>a [i]+a [i-4]&gt;=a [i-2]&amp;&amp;a [i-2]&gt;=a [i-4]&amp;&amp;a [i-1]+a [i-5]&gt;=a [i-3]&amp;&amp;a [i-1]&lt;=a [i-3]</code><br>基本都要符合相加的两条边需要大于单边，但是相加的其中一个单边不可大于对面的单边。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="comment">//outloop:</span></span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> a [<span class="number">1000010</span>];</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;a [i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>,p=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">3</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;regret&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a [i]&gt;=a [i<span class="number">-2</span>]&amp;&amp;a [i<span class="number">-1</span>]&lt;=a [i<span class="number">-3</span>])</span><br><span class="line">                    &#123;</span><br><span class="line">                        p=i;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a [i<span class="number">-1</span>]==a [i<span class="number">-3</span>]&amp;&amp;a [i<span class="number">-4</span>]+a [i]&gt;=a [i<span class="number">-2</span>])</span><br><span class="line">                    &#123;</span><br><span class="line">                        p=i;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;      </span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">5</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a [i]+a [i<span class="number">-4</span>]&gt;=a [i<span class="number">-2</span>]&amp;&amp;a [i<span class="number">-2</span>]&gt;=a [i<span class="number">-4</span>]&amp;&amp;a [i<span class="number">-1</span>]+a [i<span class="number">-5</span>]&gt;=a [i<span class="number">-3</span>]&amp;&amp;a [i<span class="number">-1</span>]&lt;=a [i<span class="number">-3</span>])</span><br><span class="line">                    &#123;</span><br><span class="line">                        p=i;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;regret&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;p+<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;P1709-渣渣辉的井字棋&quot;&gt;&lt;a href=&quot;#P1709-渣渣辉的井字棋&quot; class=&quot;headerlink&quot; title=&quot;P1709 渣渣辉的井字棋&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://sustoj.com/p/P1709&quot;&gt;P1709 渣渣辉的</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
    <category term="Algorithm" scheme="http://example.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-[每日一题] 10.15</title>
    <link href="http://example.com/2022/10/15/LeetCode10-15/"/>
    <id>http://example.com/2022/10/15/LeetCode10-15/</id>
    <published>2022-10-14T17:13:09.000Z</published>
    <updated>2022-10-15T11:38:54.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1441-用栈操作构建数组"><a href="#1441-用栈操作构建数组" class="headerlink" title="1441. 用栈操作构建数组"></a><a href="https://leetcode.cn/problems/build-an-array-with-stack-operations/">1441. 用栈操作构建数组</a></h1><p>为数不多自己能不看题解写出来的中等题<br>主要是这道题它确实简单啊不应该是中等的</p><p>给你一个数组 target 和一个整数 n。每次迭代，需要从  list &#x3D; { 1 , 2 , 3 …, n } 中依次读取一个数字。</p><p>请使用下述操作来构建目标数组 target ：</p><p>“Push”：从 list 中读取一个新元素， 并将其推入数组中。<br>“Pop”：删除数组中的最后一个元素。<br>如果目标数组构建完成，就停止读取更多元素。<br>题目数据保证目标数组严格递增，并且只包含 1 到 n 之间的数字。</p><p>请返回构建目标数组所用的操作序列。如果存在多个可行方案，返回任一即可。</p><ul><li>思路：遍历已给的目标数组，如果对应 1~n 中每个数就只 push 如果对不上就把缺的这一数直接 push 再 pop。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">buildArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; target, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; s;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;target.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target [i]==j)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                s.<span class="built_in">push_back</span>(<span class="string">&quot;Push&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                s.<span class="built_in">push_back</span>(<span class="string">&quot;Push&quot;</span>);</span><br><span class="line">                s.<span class="built_in">push_back</span>(<span class="string">&quot;Pop&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1441-用栈操作构建数组&quot;&gt;&lt;a href=&quot;#1441-用栈操作构建数组&quot; class=&quot;headerlink&quot; title=&quot;1441. 用栈操作构建数组&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/build-an</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
    <category term="Algorithm" scheme="http://example.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-[每日一题] 10.14</title>
    <link href="http://example.com/2022/10/14/LeetCode10.14/"/>
    <id>http://example.com/2022/10/14/LeetCode10.14/</id>
    <published>2022-10-14T15:24:48.000Z</published>
    <updated>2022-10-15T11:38:54.131Z</updated>
    
    <content type="html"><![CDATA[<h1 id="940-不同的子序列"><a href="#940-不同的子序列" class="headerlink" title="940. 不同的子序列"></a><a href="https://leetcode.cn/problems/distinct-subsequences-ii/">940. 不同的子序列</a></h1><p><code>字符串</code>  -  <code>Hard</code> - <code>动态规划</code></p><ul><li><p>给定一个字符串 s，计算 s 的 不同非空子序列 的个数。因为结果可能很大，所以返回答案需要对 10^9 + 7 取余 。</p></li><li><p>字符串的 子序列 是经由原字符串删除一些（也可能不删除）字符但不改变剩余字符相对位置的一个新字符串。</p></li><li><p>动态规划</p><blockquote><p>具体来说，在遍历 s 的过程中，把 s [i] 加到前 i-1 个字符组成的不同子序列的末尾，同时把 s [i] 单独作为一个子序列，即得到了前 i 个字符以 s [i] 结尾的不同子序列的个数。<br>作者：endlesscheng</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">distinctSubseqII</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 数组保存以 s [i] 作为子序列结尾时的不同子序列数量 </span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(<span class="number">26</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ch: s)&#123;</span><br><span class="line">            <span class="type">long</span> sum = <span class="number">0</span>; </span><br><span class="line">            <span class="comment">// 当前所有不同子序列的个数 </span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) </span><br><span class="line">                sum += dp [i]; </span><br><span class="line">            <span class="comment">// 再更新以 s [i] 结尾的不同子序列的个数 </span></span><br><span class="line">            a [ch-<span class="string">&#x27;a&#x27;</span>] = (sum + <span class="number">1</span>) % mod; <span class="comment">//+1 是因为有本身这个单字符 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后数组已经更新完毕 把数组累加求即可 </span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">accumulate</span>(dp.<span class="built_in">begin</span>(),dp.<span class="built_in">end</span>(),<span class="built_in">long</span>(<span class="number">0</span>))% mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;940-不同的子序列&quot;&gt;&lt;a href=&quot;#940-不同的子序列&quot; class=&quot;headerlink&quot; title=&quot;940. 不同的子序列&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/distinct-subseque</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
    <category term="Algorithm" scheme="http://example.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>OJ [每日一题] 10-14</title>
    <link href="http://example.com/2022/10/14/10-14OJ/"/>
    <id>http://example.com/2022/10/14/10-14OJ/</id>
    <published>2022-10-14T14:43:40.000Z</published>
    <updated>2022-10-15T11:38:54.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三连击"><a href="#三连击" class="headerlink" title="三连击"></a>三连击</h1><ul><li>题目描述<br>将 1, 2…9 共 9 个数分成 3 组，分别组成 3 个三位数，且使这 3 个三位数构成 1 : 2 : 3 的比例，试求出所有满足条件的 3 个三位数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k,h,s;</span><br><span class="line">    <span class="type">int</span> a [<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">123</span>;i*<span class="number">3</span>&lt;=<span class="number">987</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(h=<span class="number">1</span>;h&lt;<span class="number">10</span>;h++)</span><br><span class="line">        a [h]=<span class="number">0</span>;</span><br><span class="line">        a [i/<span class="number">100</span>]=<span class="number">1</span>;</span><br><span class="line">        a [i/<span class="number">10</span>%<span class="number">10</span>]=<span class="number">1</span>;</span><br><span class="line">        a [i%<span class="number">10</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        j=i*<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        a [j/<span class="number">100</span>]=<span class="number">1</span>;</span><br><span class="line">        a [j/<span class="number">10</span>%<span class="number">10</span>]=<span class="number">1</span>;</span><br><span class="line">        a [j%<span class="number">10</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        k=i*<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        a [k/<span class="number">100</span>]=<span class="number">1</span>;</span><br><span class="line">        a [k/<span class="number">10</span>%<span class="number">10</span>]=<span class="number">1</span>;</span><br><span class="line">        a [k%<span class="number">10</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(s=<span class="number">0</span>,h=<span class="number">1</span>;h&lt;<span class="number">10</span>;h++)</span><br><span class="line">        s=s+a [h];</span><br><span class="line">        <span class="comment">// 三个三位数的九个数字占满了下标 1-9</span></span><br><span class="line">        <span class="comment">// 说明九个数字各不同 且符合 1：2：3</span></span><br><span class="line">        <span class="keyword">if</span>(s==<span class="number">9</span>)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;i=&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; j=&quot;</span>&lt;&lt;j&lt;&lt;<span class="string">&quot; k=&quot;</span>&lt;&lt;k&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输出：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i=192 j=384 k=576</span><br><span class="line">i=219 j=438 k=657</span><br><span class="line">i=273 j=546 k=819</span><br><span class="line">i=327 j=654 k=981</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;三连击&quot;&gt;&lt;a href=&quot;#三连击&quot; class=&quot;headerlink&quot; title=&quot;三连击&quot;&gt;&lt;/a&gt;三连击&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;题目描述&lt;br&gt;将 1, 2…9 共 9 个数分成 3 组，分别组成 3 个三位数，且使这 3 个三位数构成 1 : 2</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
    <category term="Algorithm" scheme="http://example.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 链表</title>
    <link href="http://example.com/2022/10/13/Leetcode%20%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2022/10/13/Leetcode%20%E9%93%BE%E8%A1%A8/</id>
    <published>2022-10-13T15:06:12.000Z</published>
    <updated>2022-10-15T11:38:54.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-两数相加-II"><a href="#1-两数相加-II" class="headerlink" title="1. 两数相加 II"></a><a href="https://leetcode.cn/problems/add-two-numbers-ii/">1. 两数相加 II</a></h1><p>-Medium-</p><p><img src="https://pic.leetcode-cn.com/1626420025-fZfzMX-image.png" alt="aaa"></p><ul><li>给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。*</li><li>你可以假设除了数字 0 之外，这两个数字都不会以零开头 *</li></ul><p>Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 8 -&gt; 0 -&gt; 7</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt;st1;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt;st2;</span><br><span class="line">            <span class="keyword">while</span>(l1!=<span class="literal">nullptr</span>) &#123; <span class="comment">// 将链表遍历入栈 </span></span><br><span class="line">                st1.<span class="built_in">push</span>(l1-&gt;val);</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(l2!=<span class="literal">nullptr</span>)&#123; <span class="comment">// 将链表遍历入栈 </span></span><br><span class="line">                st2.<span class="built_in">push</span>(l2-&gt;val);</span><br><span class="line">                l2=l2-&gt;next;</span><br><span class="line">            &#125;       </span><br><span class="line">        <span class="type">int</span> c=<span class="number">0</span>; <span class="comment">//c 是进位 </span></span><br><span class="line">        ListNode* New=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(!st1.<span class="built_in">empty</span>()||!st2.<span class="built_in">empty</span>()||c!=<span class="number">0</span>)&#123; <span class="comment">// 循环条件：只要有一个栈不为空或者进位不为空 </span></span><br><span class="line">            <span class="type">int</span> a=st1.<span class="built_in">empty</span>()?<span class="number">0</span>:st1.<span class="built_in">top</span>(); <span class="comment">//a 就是链表 1 中的值 </span></span><br><span class="line">            <span class="type">int</span> b=st2.<span class="built_in">empty</span>()?<span class="number">0</span>:st2.<span class="built_in">top</span>(); <span class="comment">//b 就是链表 2 中的值 </span></span><br><span class="line">            <span class="keyword">if</span>(!st1.<span class="built_in">empty</span>()) st1.<span class="built_in">pop</span>(); <span class="comment">// 栈不为空时 将 a 出栈 </span></span><br><span class="line">            <span class="keyword">if</span>(!st2.<span class="built_in">empty</span>()) st2.<span class="built_in">pop</span>(); <span class="comment">// 栈不为空时 b 出栈 </span></span><br><span class="line">            <span class="type">int</span> cc=a+b+c; <span class="comment">//cc 是两结点的值之和 </span></span><br><span class="line">            c=cc/<span class="number">10</span>; <span class="comment">// 进位如果超过 10 ,/10 得 1 =&gt; 进一位 c=1</span></span><br><span class="line">            cc%=<span class="number">10</span>; <span class="comment">// 对 10 取余即取个位 </span></span><br><span class="line">            ListNode* ccnode=<span class="keyword">new</span> <span class="built_in">ListNode</span>(cc); <span class="comment">// 用 cc 值作为新结点 </span></span><br><span class="line">            ccnode-&gt;next=New; <span class="comment">// 头插法 New 一开始指向空 </span></span><br><span class="line">            New=ccnode; <span class="comment">// 再更新 New 指向刚刚插在自己上的结点 这样就会实现头插法 </span></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> Next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="2-回文链表"><a href="#2-回文链表" class="headerlink" title="2. 回文链表 "></a><a href="https://leetcode.cn/problems/aMhZSa/">2. 回文链表 </a></h1><p>-Easy-</p><p><img src="https://pic.leetcode-cn.com/1626421737-LjXceN-image.png" alt="bbb"></p><ul><li><p>给定一个链表的 头节点 head ，请判断其是否为回文链表。*</p></li><li><p>如果一个链表是回文，那么链表节点序列从前往后看和从后往前看是相同的。*</p></li><li><p>快慢指针<br>慢指针边走边掉头 ，当快指针走完了，前半个链表已经逆转结束了，然后将两个长度相等的链表挨个对比判断是否相等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode*fast=head,*slow=head,*cur=head,*pre=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>||head-&gt;next==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast&amp;&amp;fast-&gt;next)&#123;<span class="comment">// 当快指针走完了，前半个链表已经逆转结束了。</span></span><br><span class="line">            cur=slow; <span class="comment">//cur 记录当前位置 </span></span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="comment">// 头插法逆转前半部分 </span></span><br><span class="line">            cur-&gt;next=pre;</span><br><span class="line">            pre=cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast) slow=slow-&gt;next;<span class="comment">// 如果 fast 为 null  说明链表长度为单数 slow 已经在中间的结点。</span></span><br><span class="line">                                 <span class="comment">// 如果 fast 还没到 null 说明长度为偶数 再让 slow 作为后半部分的第一个 </span></span><br><span class="line">                                 <span class="comment">//slow 用作遍历后半链表 </span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 这时候开始遍历两个子链表 判断是否相等 如果相等则为回文链表 </span></span><br><span class="line">        <span class="keyword">while</span>(pre&amp;&amp;slow)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre-&gt;val==slow-&gt;val)&#123;</span><br><span class="line">                pre=pre-&gt;next;</span><br><span class="line">                slow=slow-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;             </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h1 id="3-合并有序链表"><a href="#3-合并有序链表" class="headerlink" title="3. 合并有序链表"></a><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">3. 合并有序链表</a></h1><p>-Easy-<br><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt="ccc"></p><ul><li>递归<br>利用递归不断指向两个结点中较小的一个<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">        <span class="keyword">if</span>(list2==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">        <span class="keyword">if</span>(list1-&gt;val&lt;list2-&gt;val)&#123; <span class="comment">// 看哪个头节点的值小 从小的开始 开始递归 最后返回小的头节点 </span></span><br><span class="line">            list1-&gt;next=<span class="built_in">mergeTwoLists</span>(list1-&gt;next,list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            list2-&gt;next=<span class="built_in">mergeTwoLists</span>(list1,list2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h1 id="4-相交链表"><a href="#4-相交链表" class="headerlink" title="4. 相交链表"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">4. 相交链表</a></h1><p>-Easy-</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="ddd"></p><ul><li>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。*</li><li>双指针<br>两个链表都从头结点开始挨个对比 如果不一样 就往下走 如果其中一个走到头了就指向另一个链表的头继续走 直到 A&#x3D;&#x3D;B<br>关键语句：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(A!=B)&#123;</span><br><span class="line">    A = A == <span class="literal">nullptr</span> ? headB : A-&gt;next;</span><br><span class="line">    B = B == <span class="literal">nullptr</span> ? headA : B-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>完整代码：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA==<span class="literal">NULL</span>||headB==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode*A=headA; <span class="comment">// 双指针 </span></span><br><span class="line">        ListNode*B=headB;</span><br><span class="line">        <span class="keyword">while</span>(A!=B)&#123;</span><br><span class="line">             A=A==<span class="literal">NULL</span>?headB:A-&gt;next;<span class="comment">// 判断每个指针指向的节点是否到了链表尾，</span></span><br><span class="line">            B=B==<span class="literal">NULL</span>?headA:B-&gt;next;<span class="comment">// 如果没到就往后走，否则指向另一个链表的头 直到两个指针指向同样的节点 即交点 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h1 id="5-分隔链表"><a href="#5-分隔链表" class="headerlink" title="5. 分隔链表"></a><a href="https://leetcode.cn/problems/split-linked-list-in-parts/">5. 分隔链表</a></h1><p>-Medium-<br>输入：head &#x3D; [1,2,3], k &#x3D; 5<br>输出：[ [1],[2],[3],[ ],[ ] ]</p><p>输入：head &#x3D; [1,2,3,4,5,6,7,8,9,10], k &#x3D; 3<br>输出：[ [1,2,3,4],[5,6,7],[8,9,10] ]<br>  ** 思路：**</p><ul><li>计算总长度<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ListNode* p=head;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li>计算 每段链表的平均长度 l&#x3D;cnt&#x2F;k 和 r &#x3D; 余数 cnt% k<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> r=cnt% k;</span><br><span class="line"><span class="type">int</span> l=cnt/k;</span><br></pre></td></tr></table></figure></li><li>遍历只存放每一段的头结点，有余数的话每一段多加一个。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">p=head;</span><br><span class="line">ListNode* pre=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">while</span>(p)&#123;</span><br><span class="line">    ans.<span class="built_in">push_back</span>(p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)&#123;</span><br><span class="line">pre=p;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r)&#123;</span><br><span class="line">        r--;</span><br><span class="line">        pre=p;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    pre-&gt;next=<span class="literal">NULL</span>;  断开每个段 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>此时 ans 有几个数说明有几段，总段数 k-ans.size ()&#x3D; 空位数<br>几个空就补几个 NULL <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> empty=k-ans.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;empty;i++)&#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li>最后返回 ans 数组<br><code>return ans;</code></li></ul><h1 id="6-删除倒数第-n-个结点"><a href="#6-删除倒数第-n-个结点" class="headerlink" title="6. 删除倒数第 n 个结点"></a><a href="https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/">6. 删除倒数第 n 个结点</a></h1><p>-Easy-</p><ul><li>思路：快指针和慢指针同时从头开始，快的提前走 n 个结点，然后当快的到头的时候，慢的就到了倒数第 n 个结点了，令慢指针跳过一个 即删除了。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* slow=head;</span><br><span class="line">        ListNode* fast=head;</span><br><span class="line">        <span class="keyword">while</span>(n--&gt;<span class="number">0</span>) fast=fast-&gt;next; <span class="comment">// 关键是先让快指针走 n 个 </span></span><br><span class="line">        <span class="keyword">if</span>(fast==<span class="literal">nullptr</span>) <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            fast=fast-&gt;next; <span class="comment">// 这时候快慢指针以同样的速度在走 </span></span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow-&gt;next=slow-&gt;next-&gt;next;<span class="comment">// 基本删除操作 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h1 id="7-奇偶链表"><a href="#7-奇偶链表" class="headerlink" title="7. 奇偶链表"></a><a href="https://leetcode.cn/problems/odd-even-linked-list/">7. 奇偶链表</a></h1><p>-Medium-<br><img src="https://assets.leetcode.com/uploads/2021/03/10/oddeven-linked-list.jpg" alt="奇偶链表"></p><ul><li>思路：奇指针和偶指针分别从第一个结点和第二个节点开始，只要偶指针和偶指针的下一个结点不为空就将奇指针的后继结点改为偶指针后一个结点，再让偶指针的后继结点改为此时的奇指针后一个结点，再将两个指针递增<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* evenHead = head-&gt;next;</span><br><span class="line">        ListNode* odd = head;</span><br><span class="line">        ListNode* even = evenHead;</span><br><span class="line">        <span class="keyword">while</span> (even != <span class="literal">nullptr</span> &amp;&amp; even-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            odd-&gt;next=even-&gt;next;</span><br><span class="line">            odd=even-&gt;next;</span><br><span class="line">            even-&gt;next=odd-&gt;next;</span><br><span class="line">            even=odd-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        odd-&gt;next = evenHead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;    </span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-两数相加-II&quot;&gt;&lt;a href=&quot;#1-两数相加-II&quot; class=&quot;headerlink&quot; title=&quot;1. 两数相加 II&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/add-two-numbers-ii/&quot;</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
    <category term="Algorithm" scheme="http://example.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>忏悔录 - KKecho</title>
    <link href="http://example.com/2022/10/13/%E5%BF%8F%E6%82%94%E5%BD%95/"/>
    <id>http://example.com/2022/10/13/%E5%BF%8F%E6%82%94%E5%BD%95/</id>
    <published>2022-10-12T21:06:47.000Z</published>
    <updated>2022-10-13T16:29:29.518Z</updated>
    
    <content type="html"><![CDATA[<h1 id="没有-21-还是个-savage"><a href="#没有-21-还是个-savage" class="headerlink" title="没有 21 还是个 savage"></a>没有 21 还是个 savage</h1><p>那天躺在地上的时候我就在想</p><p>曾经做过的事对妈老汉儿该咋个讲<br>**<br>** 他们都对我有恩 **</p><p>** 我不能够辜负他们我的心里很恼火 **</p><p>** 能不能好好生活这个事情我都还要仔细去雕琢 **</p><p>** 住在最贫穷的街区 **</p><p>** 他们都觉得我太脏了 **</p><p>有一天掀起了血雨</p><p>手腕上全部都挂满了钢索</p><p>wake up in the morning</p><p>我根本没想躲避</p><p>他们抓住我的软肋</p><p>And they start hit my head</p><p>As the young boi 自己忏悔</p><p>那年我才 18 岁</p><p>这的空气让我有点反胃</p><p>不太想承认我犯了罪</p><p>没有 21 还是个 savage</p><p>觉得时间还能够浪费</p><p>I will die</p><p>实在很残忍</p><p>If I dont succeed</p><p>这些年确实没出息</p><p>我性格非常的孤僻</p><p>渐渐的我学会感恩</p><p>慢慢开始变得更安分</p><p>在泥泞之中不停的翻滚</p><p>我能够成为想成为的人</p><p>always cry</p><p>长太乖</p><p>经常被欺负</p><p>我变得坏</p><p>不想再</p><p>被他们低估</p><p>I choose</p><p>I have a city to hide</p><p>I choose</p><p>I have a city to hide</p><p>** 听我说妈妈 **</p><p>** 今晚我可能就先不回家了 **</p><p>** 我要把年少轻狂的自己 SHA 了 **</p><p>看着镜子里的人 wtf eh</p><p>bloods on my hands</p><p>我逃啊逃啊逃</p><p>黑色衣裳的人也跑直到</p><p>到了死胡同</p><p>我开始爆粗口</p><p>他让我住口</p><p>对话的是 me and myself</p><p>我逃出我的身体这感觉很微妙</p><p>空气中弥漫着忏悔的味道</p><p>彩色的气泡它们将我给围绕</p><p>finally im free now</p><p>finally im free now</p><p>他们抓住我的软肋</p><p>And they start hit my head</p><p>As the young boi 自己忏悔</p><p>那年我才 18 岁</p><p>这的空气让我有点反胃</p><p>不太想承认我犯了罪</p><p>没有 21 还是个 savage</p><p>觉得时间还能够浪费</p><p>他们抓住我的软肋</p><p>And they start hit my head</p><p>As the young boi 自己忏悔那年我才 18 岁</p><p>这的空气让我有点反胃</p><p>不太想承认我犯了罪</p><p>没有 21 还是个 savage</p><p>觉得时间还能够浪费</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;没有-21-还是个-savage&quot;&gt;&lt;a href=&quot;#没有-21-还是个-savage&quot; class=&quot;headerlink&quot; title=&quot;没有 21 还是个 savage&quot;&gt;&lt;/a&gt;没有 21 还是个 savage&lt;/h1&gt;&lt;p&gt;那天躺在地上的时候我就在想&lt;</summary>
      
    
    
    
    <category term="Music" scheme="http://example.com/categories/Music/"/>
    
    
    <category term="Music" scheme="http://example.com/tags/Music/"/>
    
    <category term="KKecho" scheme="http://example.com/tags/KKecho/"/>
    
  </entry>
  
  <entry>
    <title>会魔法的老人</title>
    <link href="http://example.com/2022/10/13/%E4%BC%9A%E9%AD%94%E6%B3%95%E7%9A%84%E8%80%81%E4%BA%BA/"/>
    <id>http://example.com/2022/10/13/%E4%BC%9A%E9%AD%94%E6%B3%95%E7%9A%84%E8%80%81%E4%BA%BA/</id>
    <published>2022-10-12T20:15:35.000Z</published>
    <updated>2022-10-13T16:29:41.464Z</updated>
    
    <content type="html"><![CDATA[<div class="fj-gallery"><p><img src="/" alt="法老.jpg"></p>          </div><p>会魔法的老人</p><p>作词：法老 &#x2F; KKECHO</p><p>作曲：法老 &#x2F; KKECHO</p><p>编曲：Land James</p><p>录音：杨秋儒</p><p>混音：隆历奇</p><p>我从出生就是一个自闭小孩</p><p>容易被别人一句话给轻易伤害</p><p>所以 我在唱台上</p><p>不断的摆弄我的肢体</p><p>为了阻挡光线 和我眼神里的荒诞</p><p>独自在电影院里</p><p>观看一部杰作</p><p>野火在我的心底燃烧</p><p>梦醒生活再被截获</p><p>在闪光灯和相机</p><p>面前对爷爷的照片别过</p><p>把人生中的脆弱通过歌词演说</p><p>无法去甄别 这是错的 或者是对的</p><p>是 real 或 fake 妈妈我只是累了</p><p>我罪恶 在感情上面怀有 一丝愧色</p><p>如果我们刨开心脏 你们会说这就对了</p><p>我把它放在博物馆里展览</p><p>看着一旁熙攘的人群在逐渐汇合</p><p>有人在鼓掌 有人哭喊 有人朝他吐痰</p><p>却唯独没人 给我擦干我的泪河</p><p>故事被晒干</p><p>过程都太短</p><p>时间可以倒退用我生命来换</p><p>过路的人都已谢完了幕</p><p>一个人吃饭往往会比中药还再苦</p><p>他们只在乎 cash oh cash oh cash</p><p>我视他们为 trash oh trash oh trash</p><p>我想要跑到北上广去盖一整栋楼</p><p>我知道那些东西不急以后都会有</p><p>后来那台电视机前只剩我在换台</p><p>后来懂我的人的鬓角都已变的斑白</p><p>后来聚拢的人都随着时间滴答滴答散开</p><p>直到我 再也不敢把那回忆之书翻开</p><p>尝试在周围的窃窃私语</p><p>中 寻求治愈</p><p>在一张张的字据</p><p>里面 去避免失去</p><p>可是失去他就是会失去啊</p><p>这是所有人和事的结局</p><p>我要怎么才能做到豁达</p><p>是我的错吗？</p><p>我也想把那精致长袍脱下</p><p>换种活法</p><p>我也想转身拥抱过去</p><p>但我不会魔法</p><p>若你我相逢在人海里</p><p>请你送我一束花</p><p>我想要成为 一名 艺术家</p><p>或许走到死亡的尽头</p><p>那苍白的老人 热情早已不在他的心头</p><p>他会失忆的 但会有人把他的生命记忆拼凑</p><p>因为有关法老的故事 他们至今还没听够</p><p>故事被晒干</p><p>过程都太短</p><p>时间可以倒退用我生命来换</p><p>过路的人都已谢完了幕</p><p>一个人吃饭往往会比中药还再苦</p><p>他们只在乎 cash oh cash oh cash</p><p>我视他们为 trash oh trash oh trash</p><p>我想要跑到北上广去盖一整栋楼</p><p>我知道那些东西不急以后都会有</p>]]></content>
    
    
    <summary type="html">Pharaoh,Kkecho</summary>
    
    
    
    <category term="Music" scheme="http://example.com/categories/Music/"/>
    
    
    <category term="Music" scheme="http://example.com/tags/Music/"/>
    
    <category term="Pharaoh" scheme="http://example.com/tags/Pharaoh/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode34 【二分法】在排序数组中查找元素的第一个和最后一个位置</title>
    <link href="http://example.com/2022/10/13/Leetcode34/"/>
    <id>http://example.com/2022/10/13/Leetcode34/</id>
    <published>2022-10-12T17:09:47.000Z</published>
    <updated>2022-10-15T11:38:54.131Z</updated>
    
    <content type="html"><![CDATA[<h1 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h1><p>要求如下：给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。你必须设计并实现时间复杂度为 <em>O (log n)</em> 的算法解决此问题。</p><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>主要思想还是二分法，但是和一般的二分查找区别在于不好判断目标值在数组中的开始位置和结束位置也就是左右端点的索引值。</p><ul><li>提示：默认你已经了解基础二分查找的操作 *<br>因此我们假设已经找到了目标值但是不知道左边和右边还有没有相同的值（不知道当前这个位置是否为开始 &#x2F; 结束位置），所以设计两个函数分别找开始 &#x2F; 结束位置：GetLower，GetUpper。<br>就当成一般的二分查找来写，但是有一点区别：</li></ul><h3 id="找开始-x2F-结束位置"><a href="#找开始-x2F-结束位置" class="headerlink" title="找开始 &#x2F; 结束位置"></a>找开始 &#x2F; 结束位置</h3><p>如果想找结束位置，那么（<strong>1）当目标值大于等于 mid 值时 应该改变左指针为 mid+1 相当于将左指针向右逼近直到左指针等于右指针；<br>（2）当目标值小于 mid 值时 说明左指针已经过了要找的结束位置了，不满足循环条件：left&lt;right 了，此时的右指针会指向 mid-1，指向的就是结束位置，返回右指针（结束位置索引）</strong><br>同理，如果想找开始位置，那么当目标值小于等于 mid 值时 应该改变右指针为 mid-1，相当于将右指针向左逼近直到左指针等于右指针；后面不再赘述。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetLower</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">            <span class="type">int</span> mid = i+(j-i)/<span class="number">2</span>;</span><br><span class="line">              <span class="comment">// 如果想找开始位置，那么当目标值小于等于 mid 值时 应该改变右指针 j=mid-1，相当于将右指针向左逼近直到左指针等于右指针 </span></span><br><span class="line">            <span class="keyword">if</span>(target&lt;=nums [mid]) j=mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target&gt;nums [mid]) i=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetUpper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">            <span class="type">int</span> mid = i+(j-i)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 如果想找结束位置，那么当目标值大于等于 mid 值时 应该改变左指针 i=mid+1 相当于将左指针向右逼近直到左指针等于右指针；</span></span><br><span class="line">            <span class="keyword">if</span>(target&gt;=nums [mid]) i=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target&lt;nums [mid]) j=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在主函数中只需要加上判定语句比如开始位置大于结束位置的情况：根据题意应该返回数组 [-1,-1]<br>否则返回数组 [lower,upper]<br>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> lower=<span class="built_in">GetLower</span>(nums,target);</span><br><span class="line"><span class="type">int</span> upper=<span class="built_in">GetUpper</span>(nums,target);</span><br><span class="line"><span class="keyword">if</span>(lower&gt;upper) <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">return</span> &#123;lower,upper&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><pre><code class="cpp">class Solution &#123;public:    vector&lt;int&gt; searchRange (vector&lt;int&gt;&amp; nums, int target) &#123;int lower=GetLower (nums,target);int upper=GetUpper (nums,target);if (lower&gt;upper) return &#123;-1,-1&#125;;return &#123;lower,upper&#125;;&#125;private:    int GetLower (vector&lt;int&gt;&amp;nums, int target)&#123;        int i=0,j=nums.size ()-1;        while (i&lt;=j)&#123;            int mid = i+(j-i)/2;            if (target&lt;=nums [mid]) j=mid-1;            else if (target&gt;nums [mid]) i=mid+1;        &#125;        return i;    &#125;    int GetUpper (vector&lt;int&gt;&amp;nums, int target)&#123;        int i=0,j=nums.size ()-1;        while (i&lt;=j)&#123;            int mid = i+(j-i)/2;            if (target&gt;=nums [mid]) i=mid+1;            else if (target&lt;nums [mid]) j=mid-1;        &#125;            return j;    &#125;&#125;;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;34-在排序数组中查找元素的第一个和最后一个位置&quot;&gt;&lt;a href=&quot;#34-在排序数组中查找元素的第一个和最后一个位置&quot; class=&quot;headerlink&quot; title=&quot;34. 在排序数组中查找元素的第一个和最后一个位置&quot;&gt;&lt;/a&gt;34. 在排序数组中查找元</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
    <category term="Algorithm" scheme="http://example.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>I LOVE YOU</title>
    <link href="http://example.com/2022/03/10/%E6%88%91%E7%88%B1%E4%BD%A0/"/>
    <id>http://example.com/2022/03/10/%E6%88%91%E7%88%B1%E4%BD%A0/</id>
    <published>2022-03-10T04:30:16.000Z</published>
    <updated>2022-10-14T18:47:40.258Z</updated>
    
    <content type="html"><![CDATA[<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=386365800&bvid=BV1Ed4y1D7G3&cid=782627415&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;" ></iframe></div><div class="gallery-group-main">  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://s2.loli.net/2022/10/13/ECM3GvbBZ2ROahj.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">Shannxi</div>  <p>XACITY</p>  <a href='/gallery/XACity'></a>  </figcaption>  </figure>  </div><h1 id="This-is-a-song-called-I-Love-you"><a href="#This-is-a-song-called-I-Love-you" class="headerlink" title="This is a song called I Love you"></a>This is a song called I Love you</h1><p>我好爱你</p><p>我此刻不会再隐瞒你</p><p>在开始恋情之前我说</p><p>我没资格去评判你</p><p>你那么美丽</p><p>从头到尾散发魅力</p><p>我想和你环游世界一起去看看北极</p><p>你说 我会一直陪你陪你 一切的习惯都随你</p><p>在酒吧的前厅 窗外又开始响起雷雨</p><p>我们走出户外 在雨中开始漫长的接吻</p><p>两个不羁的人格 决定一起对世界泄愤</p><p>自由是我们的信条</p><p>心跳是信号</p><p>一起去滑板摔出青泡</p><p>但只要两个人浸泡在一起那温柔的就像摔进天堂的音道</p><p>让我们互相眼里只有彼此 把所有荷尔蒙都引爆</p><p>但世界末日我们也会分开</p><p>因为宇宙塌了下来 所以我要去给你撑开</p><p>火车轨道 只是为了我们存在</p><p>我们马上出发 就让不相干的人全滚蛋</p><p>（在一刹那 woman）</p><p>（特别的话 woman）</p><p>你是我见过镜头里最完美那 woman</p><p>（在一刹那 woman）</p><p>（特别的话 woman）</p><p>我一定不会认错那就是爱 woman</p><p>（那就是爱）越过山河和你拥吻</p><p>（这就是爱）in this moment</p><p>要多伟大的爱才能把爱这个字写的工整</p><p>我可以停止呼吸</p><p>但我不能停止爱你 woman</p><p>你说你爱听摇滚</p><p>可居然陪我喜欢说唱</p><p>你说这世界的音乐就像动物多种多样</p><p>别藐视</p><p>看海岸路边的礁石</p><p>麋鹿在天际消失</p><p>当我拉着你的手时 自然的十指交织</p><p>我们和所有当地艺术家都成为了朋友</p><p>或许他们没有成就</p><p>但从未忘记奋斗</p><p>就像现在并非旺季</p><p>我们却牵手在海边贩卖我们手工制品</p><p>青青子衿，悠悠我心</p><p>你美的好像来自诗经</p><p>你却说为我感到有文化而吃惊</p><p>我生气地在后面追着你划过了海岸线</p><p>转瞬我们就在呼伦贝尔的羊群里面 过夜</p><p>每次贴近你 我都感到大脑与呼吸 脱节</p><p>我好爱你 爱到想把此刻的时间 全部终结</p><p>我不关心火星是否有水 只关心这个冬天</p><p>我找了好几辈子的人就 站在我的身边</p><p>（在一刹那 woman）</p><p>（特别的话 woman）</p><p>你是我见过镜头里最完美那 woman</p><p>（在一刹那 woman）</p><p>（特别的话 woman）</p><p>我一定不会认错那就是爱 woman</p><p>（那就是爱）越过山河和你拥吻</p><p>（这就是爱）in this moment</p><p>要多伟大的爱才能把爱这个字写的工整</p><p>我可以停止呼吸</p><p>但我不能停止爱你 woman</p><p>我们搭建了两个人的家庭</p><p>建在房车里的咖啡厅</p><p>让那些忙碌的人 带来故事由我们聆听</p><p>我说再也不回城市</p><p>我想要自由真实</p><p>我想和你一起老去化成分子</p><p>那暖熏的风暴将把我们</p><p>卷上天空</p><p>降下雨水</p><p>滋润雄伟的天山最高尖峰</p><p>这不就是我们所追求的吗</p><p>哪怕这臭水沟 连喝水都会 硌牙</p><p>我们也做相依伴的荷花</p><p>我看着她的眼睛</p><p>语气坚定</p><p>她却 突然闪烁地像是画布上的剪影</p><p>开始变形</p><p>奇怪的光线开始交织</p><p>我大喊她的名字</p><p>她只是微笑 直到变成了蝴蝶消失</p><p>再睁开眼睛 是泪水 是害怕地把呼吸屏住</p><p>是黑暗里找她的手 摸到件工作服</p><p>忙碌的窗外 没有爱情</p><p>有混凝土 有风声在呼 有东方 明珠</p><p>（在一刹那 woman）</p><p>（特别的话 woman）</p><p>你是我见过镜头里最完美那 woman</p><p>（在一刹那 woman）</p><p>（特别的话 woman）</p><p>我一定不会认错那就是爱 woman</p><p>（那就是爱）越过山河和你拥吻</p><p>（这就是爱）in this moment</p><p>要多伟大的爱才能把爱这个字写的工整</p><p>我可以停止呼吸</p><p>但我不能停止爱你</p>]]></content>
    
    
    <summary type="html">Welcome to My Fisrt Blog</summary>
    
    
    
    <category term="Love" scheme="http://example.com/categories/Love/"/>
    
    
    <category term="Music" scheme="http://example.com/tags/Music/"/>
    
    <category term="Life" scheme="http://example.com/tags/Life/"/>
    
  </entry>
  
</feed>
